CCS PCD C Compiler, Version 4.104, 5967               07-Nov-15 15:27

               Filename: C:\Users\e882742\Documents\Robotica\RedTesla V3.0\main.lst

               ROM used: 3850 bytes (9%)
                         Largest free fragment is 41206
               RAM used: 295 (14%) at main() level
                         366 (18%) worst case
               Stack:    5 worst case (1 in main + 4 for interrupts)

*
0000:  GOTO    D38
*
0026:  DATA    EC,06,00
.................... #include <30f5015.h> 
.................... //////// Standard Header file for the DSPIC30F5015 device //////////////// 
.................... #device DSPIC30F5015 
.................... #list 
....................  
.................... #include "Config.h" 
.................... #DEVICE ADC=10 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES FRC_PLL16                //Internal Fast RC oscillator with 16X PLL 
.................... //#FUSES FRC_PLL8               //Internal Fast RC oscillator with 8X PLL 
.................... #FUSES PR_PLL                   //Primary Oscillator with PLL 
.................... #FUSES NOCKSFSM                 //Clock Switching is disabled, fail Safe clock monitor is disabled 
.................... #FUSES WPSB16                   //Watch Dog Timer PreScalar B 1:16 
.................... #FUSES WPSA512                  //Watch Dog Timer PreScalar A 1:512 
.................... #FUSES PUT64                    //Power On Reset Timer value 64ms 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORRES                 
.................... #FUSES LPOL_HIGH                //Low-Side Transistors Polarity is Active-High (PWM 0,2,4 and 6) 
....................    //PWM module low side output pins have active high output polar 
.................... #FUSES HPOL_HIGH                //High-Side Transistors Polarity is Active-High (PWM 1,3,5 and 7) 
....................    //PWM module high side output pins have active high output polarity 
.................... #FUSES NOPWMPIN                 //PWM outputs drive active state upon Reset 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOCOE                    //Device will reset into operational mode 
.................... //#FUSES ICSP1                    //ICD uses PGC1/PGD1 pins 
.................... #use delay(clock=117920000) 
*
091A:  CP0     W0
091C:  BTSC.B  42.1
091E:  BRA     92C
0920:  REPEAT  #3321
0922:  NOP     
0924:  REPEAT  #3FFF
0926:  NOP     
0928:  DEC     W0,W0
092A:  BRA     91A
092C:  RETURN  
*
0D28:  CP0     W0
0D2A:  BTSC.B  42.1
0D2C:  BRA     D36
0D2E:  REPEAT  #16
0D30:  NOP     
0D32:  DEC     W0,W0
0D34:  BRA     D28
0D36:  RETURN  
.................... //#use delay(clock=58960000) 
.................... #use rs232(UART1,baud=115200,bits=8, xmit=PIN_F3,rcv=PIN_F2, parity=N, TIMEOUT=5000) 
*
01CE:  BTSS.B  20E.0
01D0:  BRA     1CE
01D2:  PUSH    20E
01D4:  POP     800
01D6:  MOV     212,W0
01D8:  BCLR.B  20E.1
01DA:  RETURN  
.................... #DEFINE PWM_PERIOD 	1499 
.................... #DEFINE SET_POINT	16 
....................  
.................... #include "Global_Variables.c" 
....................  
.................... int16 sensors_ADC[15],black_limit=730; 
.................... int16   sensors_BIN[15],base_speed=1200,left_correction,right_correction,last_center,center,last_error,error,derivative,correction; 
.................... float   integral=0,KD=850,KP=90,KI=0; 
.................... int RUN=0xFF;// 
.................... int16 x=0,delay_time=13800; 
.................... char buffer[50]; 
.................... //KD=0,KP=125,KI=0,BaseSpeed=700 
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0D7A:  CLR     89A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
*
0342:  MOV     W5,[W15++]
0344:  MOV     W6,[W15++]
0346:  MOV     W7,[W15++]
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0348:  CLR     8E8
....................    sign = 0; 
034A:  CLR     8E4
....................    base = 10; 
034C:  MOV     #A,W4
034E:  MOV     W4,8E6
....................    result = 0; 
0350:  CLR     8E0
0352:  CLR     8E2
....................  
....................    if (!s) 
0354:  CP0     8DE
0356:  BRA     NZ,35E
....................       return 0; 
0358:  MOV     #0,W0
035A:  MOV     #0,W1
035C:  BRA     51C
....................    c = s[index++]; 
035E:  MOV     8E8,W0
0360:  INC     08E8
0362:  MOV     W0,W5
0364:  MOV     W5,W0
0366:  ADD     8DE,W0
0368:  MOV     8EA,W4
036A:  MOV.B   [W0+#0],W4L
036C:  MOV     W4,8EA
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
036E:  MOV     8EA,W4
0370:  XOR.B   #2D,W4L
0372:  BRA     NZ,38A
....................    { 
....................       sign = 1;         // Set the sign to negative 
0374:  MOV     #1,W4
0376:  MOV     W4,8E4
....................       c = s[index++]; 
0378:  MOV     8E8,W0
037A:  INC     08E8
037C:  MOV     W0,W5
037E:  MOV     W5,W0
0380:  ADD     8DE,W0
0382:  MOV     8EA,W4
0384:  MOV.B   [W0+#0],W4L
0386:  MOV     W4,8EA
....................    } 
....................    else if (c == '+') 
0388:  BRA     3A0
038A:  MOV     8EA,W4
038C:  XOR.B   #2B,W4L
038E:  BRA     NZ,3A0
....................    { 
....................       c = s[index++]; 
0390:  MOV     8E8,W0
0392:  INC     08E8
0394:  MOV     W0,W5
0396:  MOV     W5,W0
0398:  ADD     8DE,W0
039A:  MOV     8EA,W4
039C:  MOV.B   [W0+#0],W4L
039E:  MOV     W4,8EA
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
03A0:  MOV     8EA,W4
03A2:  MOV     #30,W3
03A4:  CP.B    W3L,W4L
03A6:  BRA     GTU,4FC
03A8:  MOV     8EA,W4
03AA:  MOV     #39,W3
03AC:  CP.B    W3L,W4L
03AE:  BRA     NC,4FC
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
03B0:  MOV     8EA,W4
03B2:  XOR.B   #30,W4L
03B4:  BRA     NZ,3E0
03B6:  MOV     8E8,W0
03B8:  ADD     8DE,W0
03BA:  MOV.B   [W0],W4L
03BC:  XOR.B   #78,W4L
03BE:  BRA     Z,3CA
03C0:  MOV     8E8,W0
03C2:  ADD     8DE,W0
03C4:  MOV.B   [W0],W4L
03C6:  XOR.B   #58,W4L
03C8:  BRA     NZ,3E0
....................       { 
....................          base = 16; 
03CA:  MOV     #10,W4
03CC:  MOV     W4,8E6
....................          index++; 
03CE:  INC     08E8
....................          c = s[index++]; 
03D0:  MOV     8E8,W0
03D2:  INC     08E8
03D4:  MOV     W0,W5
03D6:  MOV     W5,W0
03D8:  ADD     8DE,W0
03DA:  MOV     8EA,W4
03DC:  MOV.B   [W0+#0],W4L
03DE:  MOV     W4,8EA
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
03E0:  MOV     8E6,W4
03E2:  CP      W4,#A
03E4:  BRA     NZ,42E
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
03E6:  MOV     8EA,W4
03E8:  MOV     #30,W3
03EA:  CP.B    W3L,W4L
03EC:  BRA     GTU,42C
03EE:  MOV     8EA,W4
03F0:  MOV     #39,W3
03F2:  CP.B    W3L,W4L
03F4:  BRA     NC,42C
....................             result = 10*result + (c - '0'); 
03F6:  MOV     #A,W0
03F8:  MOV     #0,W1
03FA:  MOV     8E0,W2
03FC:  MOV     8E2,W3
03FE:  CALL    300
0402:  MOV     W0,W5
0404:  MOV     W1,W6
0406:  MOV     8EA,W4
0408:  SUB.B   #30,W4L
040A:  MOV.B   W4L,W0L
040C:  MOV.B   W0L,0
040E:  ZE      W0,W0
0410:  ADD     W0,W5,W0
0412:  MOV     W0,8E0
0414:  MOV     #0,W4
0416:  ADDC    W4,W6,W0
0418:  MOV     W0,8E2
....................             c = s[index++]; 
041A:  MOV     8E8,W0
041C:  INC     08E8
041E:  MOV     W0,W5
0420:  MOV     W5,W0
0422:  ADD     8DE,W0
0424:  MOV     8EA,W4
0426:  MOV.B   [W0+#0],W4L
0428:  MOV     W4,8EA
....................          } 
042A:  BRA     3E6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
042C:  BRA     4FC
042E:  MOV     8E6,W4
0430:  CP      W4,#10
0432:  BRA     NZ,4FC
....................       { 
....................          c = toupper(c); 
0434:  MOV     8EA,W4
0436:  MOV     #61,W3
0438:  CP.B    W3L,W4L
043A:  BRA     GTU,44A
043C:  MOV     8EA,W4
043E:  MOV     #7A,W3
0440:  CP.B    W3L,W4L
0442:  BRA     NC,44A
0444:  MOV.B   8EA,W0L
0446:  AND.B   #DF,W0L
0448:  BRA     44C
044A:  MOV.B   8EA,W0L
044C:  MOV.B   W0L,8EA
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
044E:  MOV     8EA,W4
0450:  MOV     #30,W3
0452:  CP.B    W3L,W4L
0454:  BRA     GTU,460
0456:  MOV     8EA,W4
0458:  MOV     #39,W3
045A:  CP.B    W3L,W4L
045C:  BRA     NC,460
045E:  BRA     470
0460:  MOV     8EA,W4
0462:  MOV     #41,W3
0464:  CP.B    W3L,W4L
0466:  BRA     GTU,4FC
0468:  MOV     8EA,W4
046A:  MOV     #46,W3
046C:  CP.B    W3L,W4L
046E:  BRA     NC,4FC
....................             if (c >= '0' && c <= '9') 
0470:  MOV     8EA,W4
0472:  MOV     #30,W3
0474:  CP.B    W3L,W4L
0476:  BRA     GTU,4A8
0478:  MOV     8EA,W4
047A:  MOV     #39,W3
047C:  CP.B    W3L,W4L
047E:  BRA     NC,4A8
....................                result = (result << 4) + (c - '0'); 
0480:  MOV     #4,W4
0482:  MOV     8E0,W5
0484:  MOV     8E2,W6
0486:  INC     W4,W4
0488:  DEC     W4,W4
048A:  BRA     Z,492
048C:  SL      W5,W5
048E:  RLC     W6,W6
0490:  BRA     488
0492:  MOV     8EA,W4
0494:  SUB.B   #30,W4L
0496:  MOV.B   W4L,W0L
0498:  MOV.B   W0L,0
049A:  ZE      W0,W0
049C:  ADD     W0,W5,W0
049E:  MOV     W0,8E0
04A0:  MOV     #0,W4
04A2:  ADDC    W4,W6,W0
04A4:  MOV     W0,8E2
....................             else 
04A6:  BRA     4D0
....................                result = (result << 4) + (c - 'A' + 10); 
04A8:  MOV     #4,W4
04AA:  MOV     8E0,W5
04AC:  MOV     8E2,W6
04AE:  INC     W4,W4
04B0:  DEC     W4,W4
04B2:  BRA     Z,4BA
04B4:  SL      W5,W5
04B6:  RLC     W6,W6
04B8:  BRA     4B0
04BA:  MOV     8EA,W4
04BC:  SUB.B   #41,W4L
04BE:  MOV.B   W4L,W0L
04C0:  MOV.B   W0L,0
04C2:  ADD.B   W0L,#A,W0L
04C4:  ZE      W0,W0
04C6:  ADD     W0,W5,W0
04C8:  MOV     W0,8E0
04CA:  MOV     #0,W4
04CC:  ADDC    W4,W6,W0
04CE:  MOV     W0,8E2
....................  
....................             c = s[index++];c = toupper(c); 
04D0:  MOV     8E8,W0
04D2:  INC     08E8
04D4:  MOV     W0,W5
04D6:  MOV     W5,W0
04D8:  ADD     8DE,W0
04DA:  MOV     8EA,W4
04DC:  MOV.B   [W0+#0],W4L
04DE:  MOV     W4,8EA
04E0:  MOV     8EA,W4
04E2:  MOV     #61,W3
04E4:  CP.B    W3L,W4L
04E6:  BRA     GTU,4F6
04E8:  MOV     8EA,W4
04EA:  MOV     #7A,W3
04EC:  CP.B    W3L,W4L
04EE:  BRA     NC,4F6
04F0:  MOV.B   8EA,W0L
04F2:  AND.B   #DF,W0L
04F4:  BRA     4F8
04F6:  MOV.B   8EA,W0L
04F8:  MOV.B   W0L,8EA
....................          } 
04FA:  BRA     44E
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
04FC:  MOV     8E6,W4
04FE:  CP      W4,#A
0500:  BRA     NZ,518
0502:  MOV     8E4,W4
0504:  CP      W4,#1
0506:  BRA     NZ,518
....................       result = -result; 
0508:  MOV     #0,W4
050A:  MOV     8E0,W3
050C:  SUB     W4,W3,W0
050E:  MOV     W0,8E0
0510:  MOV     #0,W4
0512:  MOV     8E2,W3
0514:  SUBB    W4,W3,W0
0516:  MOV     W0,8E2
....................  
....................    return(result); 
0518:  MOV     8E0,W0
051A:  MOV     8E2,W1
.................... } 
051C:  MOV     [--W15],W7
051E:  MOV     [--W15],W6
0520:  MOV     [--W15],W5
0522:  RETURN  
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
.................... #include "Functions.c" 
....................  
.................... void ADC_Init(void) 
.................... { 
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN5|sAN6|sAN7|sAN8|sAN9|sAN10|sAN11|sAN15);//sAN12|sAN13|sAN14|sAN15);//*******Setup ch0 and ch1 as ADC inputs in Px and Py****** 
*
08DC:  MOV     #7000,W4
08DE:  MOV     W4,2A8
08E0:  CLR     2A2
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
08E2:  MOV     #80,W4
08E4:  MOV     W4,2A4
08E6:  MOV     #80E0,W4
08E8:  MOV     W4,2A0
.................... } 
08EA:  RETURN  
....................  
.................... void Motor_Init(int16 period) 
.................... { 
....................     setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 			// en OC1 pin 46 M1        
08EC:  MOV     #E,W4
08EE:  MOV     W4,184
....................     setup_compare(2, COMPARE_PWM | COMPARE_TIMER2); 			// en OC2 pin 49 M1 
08F0:  MOV     #6,W4
08F2:  MOV     W4,18A
....................     setup_compare(3, COMPARE_PWM | COMPARE_TIMER3); 			// en OC3 pin 50 M2       
08F4:  MOV     #E,W4
08F6:  MOV     W4,190
....................    	setup_compare(4, COMPARE_PWM | COMPARE_TIMER3); 			// en OC4 pin 51 M2 
08F8:  MOV     #E,W4
08FA:  MOV     W4,196
....................   
....................     setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1,PWM_PERIOD );  
08FC:  CLR     110
08FE:  MOV     #5DB,W4
0900:  MOV     W4,10C
0902:  MOV     #A000,W4
0904:  MOV     W4,110
....................     setup_timer3(TMR_INTERNAL | TMR_DIV_BY_1,PWM_PERIOD ); 
0906:  CLR     112
0908:  MOV     #5DB,W4
090A:  MOV     W4,10E
090C:  MOV     #A000,W4
090E:  MOV     W4,112
....................  
....................     set_pwm_duty(1, 0);    										// M2 Duty 0%   LEFT+ 
0910:  CLR     180
....................     set_pwm_duty(2, 0);    										// M1 Duty 0%   LEFT- 
0912:  CLR     186
....................     set_pwm_duty(3, 0);   										// M2 Duty 0%   RIGHT- 
0914:  CLR     18C
....................     set_pwm_duty(4, 0);     									// M1 Duty 0%   RIGHT+ 
0916:  CLR     192
.................... } 
0918:  RETURN  
....................  
.................... void Set_Motor_Duty(int16 Left, int16 Right) 
.................... { 
*
01DC:  MOV     W5,[W15++]
.................... 	if(Left<0)        
01DE:  MOV     8CE,W4
01E0:  CP      W4,#0
01E2:  BRA     GE,1FA
....................     {    
....................  	   if(Left<-PWM_PERIOD )       Left=-PWM_PERIOD ; 
01E4:  MOV     8CE,W4
01E6:  MOV     #FA25,W3
01E8:  CP      W3,W4
01EA:  BRA     LE,1F0
01EC:  MOV     #FA25,W4
01EE:  MOV     W4,8CE
.................... 		set_pwm_duty(1, 0); // M2 Duty 25%  izquierdo 
01F0:  CLR     180
.................... 		set_pwm_duty(2, (int16)-Left); // M2 Duty 25%  izquierdo       
01F2:  MOV     #0,W4
01F4:  MOV     8CE,W3
01F6:  SUB     W4,W3,W5
01F8:  MOV     W5,186
.................... 	} 
.................... 	if(Left>=0)        
01FA:  MOV     8CE,W4
01FC:  CP      W4,#0
01FE:  BRA     LT,212
.................... 	{    
.................... 		if(Left>PWM_PERIOD )       Left=PWM_PERIOD ; 
0200:  MOV     8CE,W4
0202:  MOV     #5DB,W3
0204:  CP      W3,W4
0206:  BRA     GE,20C
0208:  MOV     #5DB,W4
020A:  MOV     W4,8CE
.................... 		set_pwm_duty(1, (int16)Left); // M2 Duty 25%  izquierdo 
020C:  PUSH    8CE
020E:  POP     180
.................... 		set_pwm_duty(2, 0); // M2 Duty 25%  izquierdo       
0210:  CLR     186
.................... 	} 
.................... 	if(Right<0) 
0212:  MOV     8D0,W4
0214:  CP      W4,#0
0216:  BRA     GE,22E
.................... 	{ 
.................... 		if(Right<-PWM_PERIOD )    Right=-PWM_PERIOD ; 
0218:  MOV     8D0,W4
021A:  MOV     #FA25,W3
021C:  CP      W3,W4
021E:  BRA     LE,224
0220:  MOV     #FA25,W4
0222:  MOV     W4,8D0
.................... 		set_pwm_duty(3, (int16)-Right); // M1 Duty 25%  
0224:  MOV     #0,W4
0226:  MOV     8D0,W3
0228:  SUB     W4,W3,W5
022A:  MOV     W5,18C
.................... 		set_pwm_duty(4, 0); // M1 Duty 25%  
022C:  CLR     192
.................... 	} 
.................... 	if(Right>=0) 
022E:  MOV     8D0,W4
0230:  CP      W4,#0
0232:  BRA     LT,246
.................... 	{ 
.................... 		if(Right>PWM_PERIOD )    Right=PWM_PERIOD ; 
0234:  MOV     8D0,W4
0236:  MOV     #5DB,W3
0238:  CP      W3,W4
023A:  BRA     GE,240
023C:  MOV     #5DB,W4
023E:  MOV     W4,8D0
.................... 		set_pwm_duty(3, 0); // M1 Duty 25%  
0240:  CLR     18C
.................... 		set_pwm_duty(4,(int16)Right); // M1 Duty 25%  
0242:  PUSH    8D0
0244:  POP     192
.................... 	} 
.................... } 
0246:  MOV     [--W15],W5
0248:  RETURN  
....................  
.................... void Print_Center(int16 center) 
.................... { 
.................... 	if(center<16 && center>=0)   { output_low(PIN_B12);		output_high(PIN_B14);} 
*
0B56:  MOV     8A0,W4
0B58:  CP      W4,#10
0B5A:  BRA     GE,B6A
0B5C:  MOV     8A0,W4
0B5E:  CP      W4,#0
0B60:  BRA     LT,B6A
0B62:  BCLR.B  2C7.4
0B64:  BCLR.B  2CB.4
0B66:  BCLR.B  2C7.6
0B68:  BSET.B  2CB.6
.................... 	if(center>16)   				{ output_high(PIN_B12);		output_low(PIN_B14);} 
0B6A:  MOV     8A0,W4
0B6C:  CP      W4,#10
0B6E:  BRA     LE,B78
0B70:  BCLR.B  2C7.4
0B72:  BSET.B  2CB.4
0B74:  BCLR.B  2C7.6
0B76:  BCLR.B  2CB.6
.................... 	if(center==16)   			{ output_low(PIN_B12);		output_low(PIN_B14);}  
0B78:  MOV     8A0,W4
0B7A:  CP      W4,#10
0B7C:  BRA     NZ,B86
0B7E:  BCLR.B  2C7.4
0B80:  BCLR.B  2CB.4
0B82:  BCLR.B  2C7.6
0B84:  BCLR.B  2CB.6
.................... } 
0B86:  RETURN  
....................  
.................... void Read_Sensors_Digital(int16* value_array) 
.................... { 
.................... 	*(value_array+2)=input_state(PIN_B9); 
.................... 	*(value_array+3)=input_state(PIN_B7); 
....................     *(value_array+4)=input_state(PIN_B5); 
.................... 	*(value_array+5)=input_state(PIN_B3); 
.................... 	*(value_array+6)=input_state(PIN_B1); 
.................... 	*(value_array+7)=input_state(PIN_B0); 
.................... 	*(value_array+8)=input_state(PIN_B2); 
.................... 	*(value_array+9)=input_state(PIN_B4); 
.................... 	*(value_array+10)=input_state(PIN_B6); 
.................... 	*(value_array+11)=input_state(PIN_B8); 
.................... 	*(value_array+12)=input_state(PIN_B10); 
.................... } 
....................  
.................... void Read_Sensors(int16* value_array) 
.................... { 
*
092E:  MOV     W5,[W15++]
.................... 	set_adc_channel(9);  
0930:  MOV     #9,W4
0932:  MOV     W4,2A6
.................... 	*(value_array+2)=read_ADC(); 
0934:  MOV     8A0,W4
0936:  ADD     W4,#4,W4
0938:  MOV     W4,W0
093A:  MOV     W0,W5
093C:  BCLR.B  2A0.0
093E:  BSET.B  2A0.1
0940:  BTSS.B  2A0.0
0942:  BRA     940
0944:  MOV     280,W4
0946:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0948:  REPEAT  #91
094A:  NOP     
.................... 	set_adc_channel(7);  
094C:  MOV     #7,W4
094E:  MOV     W4,2A6
.................... 	*(value_array+3)=read_ADC(); 
0950:  MOV     8A0,W4
0952:  ADD     W4,#6,W4
0954:  MOV     W4,W0
0956:  MOV     W0,W5
0958:  BCLR.B  2A0.0
095A:  BSET.B  2A0.1
095C:  BTSS.B  2A0.0
095E:  BRA     95C
0960:  MOV     280,W4
0962:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0964:  REPEAT  #91
0966:  NOP     
.................... 	set_adc_channel(5);  
0968:  MOV     #5,W4
096A:  MOV     W4,2A6
.................... 	*(value_array+4)=read_ADC(); 
096C:  MOV     8A0,W4
096E:  ADD     W4,#8,W4
0970:  MOV     W4,W0
0972:  MOV     W0,W5
0974:  BCLR.B  2A0.0
0976:  BSET.B  2A0.1
0978:  BTSS.B  2A0.0
097A:  BRA     978
097C:  MOV     280,W4
097E:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0980:  REPEAT  #91
0982:  NOP     
.................... 	set_adc_channel(3);  
0984:  MOV     #3,W4
0986:  MOV     W4,2A6
.................... 	*(value_array+5)=read_ADC(); 
0988:  MOV     8A0,W4
098A:  ADD     W4,#A,W4
098C:  MOV     W4,W0
098E:  MOV     W0,W5
0990:  BCLR.B  2A0.0
0992:  BSET.B  2A0.1
0994:  BTSS.B  2A0.0
0996:  BRA     994
0998:  MOV     280,W4
099A:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
099C:  REPEAT  #91
099E:  NOP     
.................... 	set_adc_channel(1);  
09A0:  MOV     #1,W4
09A2:  MOV     W4,2A6
.................... 	*(value_array+6)=read_ADC(); 
09A4:  MOV     8A0,W4
09A6:  ADD     W4,#C,W4
09A8:  MOV     W4,W0
09AA:  MOV     W0,W5
09AC:  BCLR.B  2A0.0
09AE:  BSET.B  2A0.1
09B0:  BTSS.B  2A0.0
09B2:  BRA     9B0
09B4:  MOV     280,W4
09B6:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
09B8:  REPEAT  #91
09BA:  NOP     
.................... 	set_adc_channel(0);			//Center sensor			  
09BC:  CLR     2A6
.................... 	*(value_array+7)=read_ADC(); 
09BE:  MOV     8A0,W4
09C0:  ADD     W4,#E,W4
09C2:  MOV     W4,W0
09C4:  MOV     W0,W5
09C6:  BCLR.B  2A0.0
09C8:  BSET.B  2A0.1
09CA:  BTSS.B  2A0.0
09CC:  BRA     9CA
09CE:  MOV     280,W4
09D0:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
09D2:  REPEAT  #91
09D4:  NOP     
.................... 	set_adc_channel(2);  
09D6:  MOV     #2,W4
09D8:  MOV     W4,2A6
.................... 	*(value_array+8)=read_ADC(); 
09DA:  MOV     8A0,W4
09DC:  ADD     W4,#10,W4
09DE:  MOV     W4,W0
09E0:  MOV     W0,W5
09E2:  BCLR.B  2A0.0
09E4:  BSET.B  2A0.1
09E6:  BTSS.B  2A0.0
09E8:  BRA     9E6
09EA:  MOV     280,W4
09EC:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
09EE:  REPEAT  #91
09F0:  NOP     
.................... 	set_adc_channel(4);  
09F2:  MOV     #4,W4
09F4:  MOV     W4,2A6
.................... 	*(value_array+9)=read_ADC(); 
09F6:  MOV     8A0,W4
09F8:  ADD     W4,#12,W4
09FA:  MOV     W4,W0
09FC:  MOV     W0,W5
09FE:  BCLR.B  2A0.0
0A00:  BSET.B  2A0.1
0A02:  BTSS.B  2A0.0
0A04:  BRA     A02
0A06:  MOV     280,W4
0A08:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0A0A:  REPEAT  #91
0A0C:  NOP     
.................... 	set_adc_channel(6);  
0A0E:  MOV     #6,W4
0A10:  MOV     W4,2A6
.................... 	*(value_array+10)=read_ADC(); 
0A12:  MOV     8A0,W4
0A14:  ADD     W4,#14,W4
0A16:  MOV     W4,W0
0A18:  MOV     W0,W5
0A1A:  BCLR.B  2A0.0
0A1C:  BSET.B  2A0.1
0A1E:  BTSS.B  2A0.0
0A20:  BRA     A1E
0A22:  MOV     280,W4
0A24:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0A26:  REPEAT  #91
0A28:  NOP     
.................... 	set_adc_channel(8);  
0A2A:  MOV     #8,W4
0A2C:  MOV     W4,2A6
.................... 	*(value_array+11)=read_ADC(); 
0A2E:  MOV     8A0,W4
0A30:  ADD     W4,#16,W4
0A32:  MOV     W4,W0
0A34:  MOV     W0,W5
0A36:  BCLR.B  2A0.0
0A38:  BSET.B  2A0.1
0A3A:  BTSS.B  2A0.0
0A3C:  BRA     A3A
0A3E:  MOV     280,W4
0A40:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0A42:  REPEAT  #91
0A44:  NOP     
.................... 	set_adc_channel(10);  
0A46:  MOV     #A,W4
0A48:  MOV     W4,2A6
.................... 	*(value_array+12)=read_ADC(); 
0A4A:  MOV     8A0,W4
0A4C:  ADD     W4,#18,W4
0A4E:  MOV     W4,W0
0A50:  MOV     W0,W5
0A52:  BCLR.B  2A0.0
0A54:  BSET.B  2A0.1
0A56:  BTSS.B  2A0.0
0A58:  BRA     A56
0A5A:  MOV     280,W4
0A5C:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0A5E:  REPEAT  #91
0A60:  NOP     
.................... } 
0A62:  MOV     [--W15],W5
0A64:  RETURN  
....................  
.................... void Get_Black_Limit(int16* limit,int st_index,int end_index,int16* array) 
.................... { 
.................... 	int i=0; 
.................... 	int16 min=1024,max=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
.................... 	{	 
.................... 		if(*(array+i)>max) max=*(array+i); 
.................... 		if(*(array+i)<min) min=*(array+i); 
.................... 	} 
.................... 	if((max-min)>204) *limit=min+(max-min)/2;//Limite un 80% arriba del minimo 
.................... } 
....................  
.................... void Digitalize_Array(int16* array_ADC,int16* array_BIN,int16 limit,int st_index,int end_index) 
.................... { 
0A66:  MOV     W5,[W15++]
0A68:  CLR     8AA
.................... 	int i=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
0A6A:  PUSH    8A6
0A6C:  POP     8AA
0A6E:  MOV     8AA,W0
0A70:  MOV     8A8,W4
0A72:  CP      W4,W0
0A74:  BRA     LT,AB6
.................... 	{	 
.................... 		if(*(array_ADC+i)>limit) *(array_BIN+i)=0; 
0A76:  MOV     8AA,W4
0A78:  MUL.UU  W4,#2,W0
0A7A:  MOV     8A0,W4
0A7C:  ADD     W0,W4,W0
0A7E:  MOV     [W0],W5
0A80:  MOV     8A4,W4
0A82:  CP      W4,W5
0A84:  BRA     GE,A94
0A86:  MOV     8AA,W4
0A88:  MUL.UU  W4,#2,W0
0A8A:  MOV     8A2,W4
0A8C:  ADD     W0,W4,W0
0A8E:  MOV     W0,W5
0A90:  MOV     #0,W4
0A92:  MOV     W4,[W5+#0]
.................... 		if(*(array_ADC+i)<=limit)*(array_BIN+i)=1; 
0A94:  MOV     8AA,W4
0A96:  MUL.UU  W4,#2,W0
0A98:  MOV     8A0,W4
0A9A:  ADD     W0,W4,W0
0A9C:  MOV     [W0],W5
0A9E:  MOV     8A4,W4
0AA0:  CP      W4,W5
0AA2:  BRA     LT,AB2
0AA4:  MOV     8AA,W4
0AA6:  MUL.UU  W4,#2,W0
0AA8:  MOV     8A2,W4
0AAA:  ADD     W0,W4,W0
0AAC:  MOV     W0,W5
0AAE:  MOV     #1,W4
0AB0:  MOV     W4,[W5+#0]
.................... 	} 
0AB2:  INC     08AA
0AB4:  BRA     A6E
.................... } 
0AB6:  MOV     [--W15],W5
0AB8:  RETURN  
.................... void Get_Average_Center_Digital(int16* array_BIN,int st_index,int end_index,int16* center) 
.................... { 
.................... 	int i=0; 
.................... 	int16 pixels_w=0,values_w=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
.................... 	{	 
.................... 		if(*(array_BIN+i)==1) 
.................... 			{ 
.................... 				values_w=values_w+((i+1)*2); 
.................... 				pixels_w=pixels_w+1; 
.................... 			} 
.................... 	} 
.................... 	if(pixels_w!=0 ) *center=values_w/pixels_w; 
.................... 	else *center=-1; 
.................... } 
....................  
.................... void Get_Average_Center(int16* array_BIN,int st_index,int end_index,int16* center) 
.................... { 
0ABA:  MOV     W5,[W15++]
0ABC:  CLR     8A8
0ABE:  CLR     8AA
0AC0:  CLR     8AC
0AC2:  CLR     8AE
0AC4:  CLR     8B0
.................... 	int i=0; 
.................... 	int16 pixels_b=0,values_b=0,pixels_w=0,values_w=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
0AC6:  PUSH    8A2
0AC8:  POP     8A8
0ACA:  MOV     8A8,W0
0ACC:  MOV     8A4,W4
0ACE:  CP      W4,W0
0AD0:  BRA     LT,B16
.................... 	{	 
.................... 		if(*(array_BIN+i)==1) 
0AD2:  MOV     8A8,W4
0AD4:  MUL.UU  W4,#2,W0
0AD6:  MOV     8A0,W4
0AD8:  ADD     W0,W4,W0
0ADA:  MOV     [W0],W5
0ADC:  CP      W5,#1
0ADE:  BRA     NZ,AF2
.................... 			{ 
.................... 				values_w=values_w+((i+1))*2; 
0AE0:  MOV     8A8,W4
0AE2:  ADD     W4,#1,W4
0AE4:  MOV     W4,W5
0AE6:  MOV     W5,W4
0AE8:  MUL.UU  W4,#2,W0
0AEA:  ADD     8B0
.................... 				pixels_w=pixels_w+1; 
0AEC:  MOV     8AE,W4
0AEE:  ADD     W4,#1,W4
0AF0:  MOV     W4,8AE
.................... 			} 
.................... 		if(*(array_BIN+i)==0) 
0AF2:  MOV     8A8,W4
0AF4:  MUL.UU  W4,#2,W0
0AF6:  MOV     8A0,W4
0AF8:  ADD     W0,W4,W0
0AFA:  MOV     [W0],W5
0AFC:  CP0     W5
0AFE:  BRA     NZ,B12
.................... 			{ 
.................... 				values_b=values_b+((i+1))*2; 
0B00:  MOV     8A8,W4
0B02:  ADD     W4,#1,W4
0B04:  MOV     W4,W5
0B06:  MOV     W5,W4
0B08:  MUL.UU  W4,#2,W0
0B0A:  ADD     8AC
.................... 				pixels_b=pixels_b+1; 
0B0C:  MOV     8AA,W4
0B0E:  ADD     W4,#1,W4
0B10:  MOV     W4,8AA
.................... 			} 
.................... 	} 
0B12:  INC     08A8
0B14:  BRA     ACA
.................... 	if(pixels_w!=11 && pixels_b!=11 )  
0B16:  MOV     8AE,W4
0B18:  CP      W4,#B
0B1A:  BRA     Z,B4C
0B1C:  MOV     8AA,W4
0B1E:  CP      W4,#B
0B20:  BRA     Z,B4C
.................... 		{ 
.................... 			if(pixels_w<pixels_b) *center=values_w/pixels_w; 
0B22:  MOV     8AE,W0
0B24:  MOV     8AA,W4
0B26:  CP      W4,W0
0B28:  BRA     LE,B36
0B2A:  MOV     8A6,W5
0B2C:  MOV     8B0,W4
0B2E:  MOV     8AE,W3
0B30:  REPEAT  #11
0B32:  DIV.S   W4,W3
0B34:  MOV     W0,[W5]
.................... 			if(pixels_b<pixels_w) *center=values_b/pixels_b; 
0B36:  MOV     8AA,W0
0B38:  MOV     8AE,W4
0B3A:  CP      W4,W0
0B3C:  BRA     LE,B4A
0B3E:  MOV     8A6,W5
0B40:  MOV     8AC,W4
0B42:  MOV     8AA,W3
0B44:  REPEAT  #11
0B46:  DIV.S   W4,W3
0B48:  MOV     W0,[W5]
.................... 		} 
.................... 	else *center=-1; 
0B4A:  BRA     B52
0B4C:  MOV     8A6,W5
0B4E:  MOV     #FFFF,W4
0B50:  MOV     W4,[W5+#0]
.................... } 
0B52:  MOV     [--W15],W5
0B54:  RETURN  
....................  
.................... void Powered_Error(float error, float* correction, float max, float max_c) 
.................... { 
.................... 	float step=1,value; 
.................... 	step=step/max; 
.................... 	if(error!=0) 
.................... 	{ 
.................... 		step=error*step; 
.................... 		value=step*step; 
.................... 		*correction=max_c*value; 
.................... 		if(error<0)	*correction=*correction*-1; 
.................... 	} 
.................... 	else *correction=0; 
.................... 	 
.................... } 
....................  
.................... void Get_Value(float* val) 
.................... {	 
*
05E0:  MOV     W5,[W15++]
05E2:  MOV     W6,[W15++]
05E4:  CLR     8D6
.................... 	int i=0; 
.................... 	do 
....................     {	 
.................... 		buffer[i]=getc(); 
05E6:  MOV     #868,W4
05E8:  MOV     8D6,W3
05EA:  ADD     W3,W4,W5
05EC:  MOV     FE8,W6
05EE:  CALL    1CE
05F2:  MOV     W6,FE8
05F4:  MOV.B   W0L,[W5]
.................... 		i++; 
05F6:  INC     08D6
....................     }while(buffer[i-1]!=13); 
05F8:  MOV     8D6,W4
05FA:  SUB     W4,#1,W5
05FC:  MOV     #868,W4
05FE:  ADD     W5,W4,W0
0600:  MOV.B   [W0],W4L
0602:  CP.B    W4L,#D
0604:  BRA     NZ,5E6
.................... 	x=atol(buffer); 
0606:  MOV     #868,W4
0608:  MOV     W4,8DE
060A:  CALL    342
060E:  MOV     W0,864
.................... 	*val=x;		 
0610:  MOV     8D4,W5
0612:  MOV     864,W0
0614:  CALL    596
0618:  MOV     #0,W4
061A:  MOV     [W4++],[W5++]
061C:  MOV     [W4++],[W5++]
.................... 	putc(13); 
061E:  MOV.B   #D,W0L
0620:  BTSC.B  20F.1
0622:  BRA     620
0624:  MOV.B   W0L,210
0626:  CLR.B   211
.................... } 
0628:  MOV     [--W15],W6
062A:  MOV     [--W15],W5
062C:  RETURN  
....................  
.................... void Get_Value_L(int16* val) 
.................... {	 
*
0524:  MOV     W5,[W15++]
0526:  MOV     W6,[W15++]
0528:  CLR     8D4
.................... 	int i=0; 
.................... 	do 
....................     {	 
.................... 		buffer[i]=getc(); 
052A:  MOV     #868,W4
052C:  MOV     8D4,W3
052E:  ADD     W3,W4,W5
0530:  MOV     FE8,W6
0532:  CALL    1CE
0536:  MOV     W6,FE8
0538:  MOV.B   W0L,[W5]
.................... 		i++; 
053A:  INC     08D4
....................     }while(buffer[i-1]!=13); 
053C:  MOV     8D4,W4
053E:  SUB     W4,#1,W5
0540:  MOV     #868,W4
0542:  ADD     W5,W4,W0
0544:  MOV.B   [W0],W4L
0546:  CP.B    W4L,#D
0548:  BRA     NZ,52A
.................... 	x=atol(buffer); 
054A:  MOV     #868,W4
054C:  MOV     W4,8DE
054E:  CALL    342
0552:  MOV     W0,864
.................... 	*val=x;		 
0554:  MOV     8D2,W5
0556:  MOV     864,W4
0558:  MOV     W4,[W5+#0]
.................... 	putc(13); 
055A:  MOV.B   #D,W0L
055C:  BTSC.B  20F.1
055E:  BRA     55C
0560:  MOV.B   W0L,210
0562:  CLR.B   211
.................... } 
0564:  MOV     [--W15],W6
0566:  MOV     [--W15],W5
0568:  RETURN  
....................  
.................... #INT_RDA 
.................... void isr() 
.................... {	 
*
06EC:  PUSH    42
06EE:  PUSH    36
06F0:  MOV     W0,[W15++]
06F2:  MOV     #2,W0
06F4:  REPEAT  #C
06F6:  MOV     [W0++],[W15++]
06F8:  MOV     #1,W3
06FA:  MOV     #0,W2
06FC:  MOV     #8CC,W1
06FE:  MOV     W2,W0
0700:  MOV     W3,[W15++]
0702:  CALL    100
0706:  MOV     [--W15],W3
0708:  MOV.B   W0L,[W1++]
070A:  INC     W2,W2
070C:  DEC     W3,W3
070E:  BTSS.B  42.1
0710:  BRA     6FE
.................... 	char option="r"; 
.................... 	option=getc(); 
0712:  CALL    1CE
0716:  MOV.B   W0L,8CC
.................... 	if(option=='r') 
0718:  MOV     8CC,W4
071A:  XOR.B   #72,W4L
071C:  BRA     NZ,72C
.................... 		{ 
.................... 			RUN=!RUN; 
071E:  CP0     862
0720:  BRA     Z,726
0722:  CLR.B   W0
0724:  BRA     728
0726:  MOV.B   #1,W0L
0728:  MOV.B   W0L,862
072A:  CLR.B   863
.................... 		} 
.................... 	if(option=='c') 
072C:  MOV     8CC,W4
072E:  XOR.B   #63,W4L
0730:  BRA     NZ,8C8
.................... 	{		 
.................... 		Set_Motor_Duty(0,0); 
0732:  CLR     8CE
0734:  CLR     8D0
0736:  CALL    1DC
.................... 		printf("base_speed=%u value=",base_speed); 
073A:  MOV     #0,W1
073C:  MOV     W1,W0
073E:  CALL    10E
0742:  INC     W1,W1
0744:  MOV     W1,[W15++]
0746:  BTSC.B  20F.1
0748:  BRA     746
074A:  MOV     W0,210
074C:  MOV     [--W15],W1
074E:  MOV     #A,W0
0750:  CPSGT   W1,W0
0752:  BRA     73C
0754:  MOV     840,W0
0756:  MOV     #0,W4
0758:  CALL    24A
075C:  MOV     #D,W1
075E:  MOV     W1,W0
0760:  CALL    10E
0764:  INC     W1,W1
0766:  MOV     W1,[W15++]
0768:  BTSC.B  20F.1
076A:  BRA     768
076C:  MOV     W0,210
076E:  MOV     [--W15],W1
0770:  MOV     #13,W0
0772:  CPSGT   W1,W0
0774:  BRA     75E
.................... 		Get_Value_L(&base_speed); 
0776:  MOV     #840,W4
0778:  MOV     W4,8D2
077A:  CALL    524
.................... 		printf("delay_time=%u value(ms)=",delay_time); 
077E:  MOV     #0,W1
0780:  MOV     W1,W0
0782:  CALL    130
0786:  INC     W1,W1
0788:  MOV     W1,[W15++]
078A:  BTSC.B  20F.1
078C:  BRA     78A
078E:  MOV     W0,210
0790:  MOV     [--W15],W1
0792:  MOV     #A,W0
0794:  CPSGT   W1,W0
0796:  BRA     780
0798:  MOV     866,W0
079A:  MOV     #0,W4
079C:  CALL    24A
07A0:  MOV     #D,W1
07A2:  MOV     W1,W0
07A4:  CALL    130
07A8:  INC     W1,W1
07AA:  MOV     W1,[W15++]
07AC:  BTSC.B  20F.1
07AE:  BRA     7AC
07B0:  MOV     W0,210
07B2:  MOV     [--W15],W1
07B4:  MOV     #17,W0
07B6:  CPSGT   W1,W0
07B8:  BRA     7A2
.................... 		Get_Value_L(&delay_time); 
07BA:  MOV     #866,W4
07BC:  MOV     W4,8D2
07BE:  CALL    524
.................... 		printf("KP=%u value=",(int16)KP); 
07C2:  MOV     85A,W0
07C4:  MOV     85C,W1
07C6:  CALL    56A
07CA:  MOV     W0,W5
07CC:  BTSC.B  20F.1
07CE:  BRA     7CC
07D0:  MOV     #4B,W4
07D2:  MOV     W4,210
07D4:  BTSC.B  20F.1
07D6:  BRA     7D4
07D8:  MOV     #50,W4
07DA:  MOV     W4,210
07DC:  BTSC.B  20F.1
07DE:  BRA     7DC
07E0:  MOV     #3D,W4
07E2:  MOV     W4,210
07E4:  MOV     W5,W0
07E6:  MOV     #0,W4
07E8:  CALL    24A
07EC:  MOV     #5,W1
07EE:  MOV     W1,W0
07F0:  CALL    156
07F4:  INC     W1,W1
07F6:  MOV     W1,[W15++]
07F8:  BTSC.B  20F.1
07FA:  BRA     7F8
07FC:  MOV     W0,210
07FE:  MOV     [--W15],W1
0800:  MOV     #B,W0
0802:  CPSGT   W1,W0
0804:  BRA     7EE
.................... 		Get_Value(&KP);	 
0806:  MOV     #85A,W4
0808:  MOV     W4,8D4
080A:  CALL    5E0
.................... 		printf("KI=%u value(x0.01)=",(int16)KI); 
080E:  MOV     85E,W0
0810:  MOV     860,W1
0812:  CALL    56A
0816:  MOV     W0,W5
0818:  BTSC.B  20F.1
081A:  BRA     818
081C:  MOV     #4B,W4
081E:  MOV     W4,210
0820:  BTSC.B  20F.1
0822:  BRA     820
0824:  MOV     #49,W4
0826:  MOV     W4,210
0828:  BTSC.B  20F.1
082A:  BRA     828
082C:  MOV     #3D,W4
082E:  MOV     W4,210
0830:  MOV     W5,W0
0832:  MOV     #0,W4
0834:  CALL    24A
0838:  MOV     #5,W1
083A:  MOV     W1,W0
083C:  CALL    170
0840:  INC     W1,W1
0842:  MOV     W1,[W15++]
0844:  BTSC.B  20F.1
0846:  BRA     844
0848:  MOV     W0,210
084A:  MOV     [--W15],W1
084C:  MOV     #12,W0
084E:  CPSGT   W1,W0
0850:  BRA     83A
.................... 		Get_Value(&KI); 
0852:  MOV     #85E,W4
0854:  MOV     W4,8D4
0856:  CALL    5E0
.................... 		KI=KI*.01; 
085A:  MOV     85E,W0
085C:  MOV     860,W1
085E:  MOV     #D70A,W2
0860:  MOV     #3C23,W3
0862:  CALL    62E
0866:  MOV     W0,85E
0868:  MOV     W1,860
.................... 		printf("KD=%u value=(x0.1)",(int16)KD); 
086A:  MOV     856,W0
086C:  MOV     858,W1
086E:  CALL    56A
0872:  MOV     W0,W5
0874:  BTSC.B  20F.1
0876:  BRA     874
0878:  MOV     #4B,W4
087A:  MOV     W4,210
087C:  BTSC.B  20F.1
087E:  BRA     87C
0880:  MOV     #44,W4
0882:  MOV     W4,210
0884:  BTSC.B  20F.1
0886:  BRA     884
0888:  MOV     #3D,W4
088A:  MOV     W4,210
088C:  MOV     W5,W0
088E:  MOV     #0,W4
0890:  CALL    24A
0894:  MOV     #5,W1
0896:  MOV     W1,W0
0898:  CALL    190
089C:  INC     W1,W1
089E:  MOV     W1,[W15++]
08A0:  BTSC.B  20F.1
08A2:  BRA     8A0
08A4:  MOV     W0,210
08A6:  MOV     [--W15],W1
08A8:  MOV     #11,W0
08AA:  CPSGT   W1,W0
08AC:  BRA     896
.................... 		Get_Value(&KD);  
08AE:  MOV     #856,W4
08B0:  MOV     W4,8D4
08B2:  CALL    5E0
.................... 		KD=KD*.1;    
08B6:  MOV     856,W0
08B8:  MOV     858,W1
08BA:  MOV     #CCCD,W2
08BC:  MOV     #3DCC,W3
08BE:  CALL    62E
08C2:  MOV     W0,856
08C4:  MOV     W1,858
.................... 		RUN=0; 
08C6:  CLR     862
.................... 	}	 
.................... 	output_toggle(PIN_D5); 
08C8:  BCLR.B  2D2.5
08CA:  BTG.B   2D6.5
.................... } 
....................  
....................  
08CC:  BCLR.B  85.1
08CE:  MOV     #1A,W0
08D0:  REPEAT  #C
08D2:  MOV     [--W15],[W0--]
08D4:  MOV     [--W15],W0
08D6:  POP     36
08D8:  POP     42
08DA:  RETFIE  
.................... void ADC_Init(void); 
.................... void Motor_Init(int16 period); 
.................... void Set_Motor_Duty(int16 Left, int16 Right); 
.................... void Print_Center(int16 center); 
....................  
.................... void Read_Sensors(int16* value_array); 
.................... void Read_Sensors_Digital(int16* value_array); 
.................... void Get_Black_Limit(int16 limit,int st_index,int end_index,int16* array); 
.................... void Digitalize_Array(int16* array_ADC,int16* array_BIN,int16 limit,int st_index,int end_index); 
.................... void Get_Average_Center(int16* array_BIN,int st_index,int end_index,int16* center); 
.................... void Get_Average_Center_Digital(int16* array_BIN,int st_index,int end_index,int16* center); 
.................... void Powered_Error(float error, float* correction, float max, float max_c); 
.................... void Get_Value(float* val); 
.................... void Get_Value_L(int16* val); 
....................  
....................  
....................  
....................  
.................... void main (void) 
.................... {	 
*
0D38:  BSET.B  81.7
0D3A:  MOV     #8000,W4
0D3C:  MOV     W4,20C
0D3E:  MOV     #400,W4
0D40:  MOV     W4,20E
0D42:  MOV     #F,W4
0D44:  MOV     W4,214
0D46:  MOV     #2DA,W4
0D48:  MOV     W4,820
0D4A:  MOV     #4B0,W4
0D4C:  MOV     W4,840
0D4E:  CLR     852
0D50:  CLR     854
0D52:  MOV     #8000,W4
0D54:  MOV     W4,856
0D56:  MOV     #4454,W4
0D58:  MOV     W4,858
0D5A:  CLR     85A
0D5C:  MOV     #42B4,W4
0D5E:  MOV     W4,85C
0D60:  CLR     85E
0D62:  CLR     860
0D64:  MOV     #FF,W4
0D66:  MOV     W4,862
0D68:  CLR     864
0D6A:  MOV     #35E8,W4
0D6C:  MOV     W4,866
0D6E:  SETM    2A8
0D70:  MOV     #F80,W15
0D72:  MOV     #FFF,W0
0D74:  MOV     W0,20
0D76:  NOP     
.................... 	printf("System enabled\n\r"); 
*
0D7C:  MOV     #0,W1
0D7E:  MOV     W1,W0
0D80:  CALL    1B0
0D84:  INC     W1,W1
0D86:  MOV     W1,[W15++]
0D88:  BTSC.B  20F.1
0D8A:  BRA     D88
0D8C:  MOV     W0,210
0D8E:  MOV     [--W15],W1
0D90:  MOV     #F,W0
0D92:  CPSGT   W1,W0
0D94:  BRA     D7E
.................... 	ADC_Init(); 
0D96:  CALL    8DC
.................... 	Motor_Init(PWM_PERIOD); 
0D9A:  MOV     #5DB,W4
0D9C:  MOV     W4,8A0
0D9E:  CALL    8EC
....................     enable_interrupts(INT_RDA); 
0DA2:  BSET.B  8D.1
.................... 	while(TRUE) 
.................... 	{	 
.................... 		Set_Motor_Duty(0,0); 
0DA4:  PUSH    42
0DA6:  SETM.B  42
0DA8:  CLR     8CE
0DAA:  CLR     8D0
0DAC:  CALL    1DC
0DB0:  POP     42
.................... 		while(!input_state(PIN_D8))// && !RUN)   //While loop used for waiting an input high  in D8 to start 
....................    		{ 
0DB2:  BTSC.B  2D5.0
0DB4:  BRA     DC2
.................... 			output_toggle(PIN_D5); 
0DB6:  BCLR.B  2D2.5
0DB8:  BTG.B   2D6.5
....................       		delay_ms(250); 
0DBA:  MOV     #FA,W0
0DBC:  CALL    91A
....................    		} 
0DC0:  BRA     DB2
.................... 		delay_ms(2000); 
0DC2:  MOV     #7D0,W0
0DC4:  CALL    91A
.................... 		if(!RUN) RUN=!RUN; 
0DC8:  CP0     862
0DCA:  BRA     NZ,DDA
0DCC:  CP0     862
0DCE:  BRA     Z,DD4
0DD0:  CLR.B   W0
0DD2:  BRA     DD6
0DD4:  MOV.B   #1,W0L
0DD6:  MOV.B   W0L,862
0DD8:  CLR.B   863
.................... 		while(RUN) 
.................... 		{ 
0DDA:  CP0     862
0DDC:  BRA     Z,F06
.................... 			output_toggle(PIN_D5); 
0DDE:  BCLR.B  2D2.5
0DE0:  BTG.B   2D6.5
.................... 			Read_Sensors(sensors_ADC); 
0DE2:  MOV     #802,W4
0DE4:  MOV     W4,8A0
0DE6:  CALL    92E
.................... 			Digitalize_Array(Sensors_ADC,Sensors_BIN,Black_Limit,0,14); 
0DEA:  CLR     8A6
0DEC:  MOV     #E,W4
0DEE:  MOV     W4,8A8
0DF0:  MOV     #802,W4
0DF2:  MOV     W4,8A0
0DF4:  MOV     #822,W4
0DF6:  MOV     W4,8A2
0DF8:  PUSH    820
0DFA:  POP     8A4
0DFC:  CALL    A66
.................... 			Get_Average_Center(Sensors_BIN,2,12,&Center);   
0E00:  MOV     #2,W4
0E02:  MOV     W4,8A2
0E04:  MOV     #C,W4
0E06:  MOV     W4,8A4
0E08:  MOV     #822,W4
0E0A:  MOV     W4,8A0
0E0C:  MOV     #848,W4
0E0E:  MOV     W4,8A6
0E10:  CALL    ABA
....................          	//Read_Sensors_Digital(sensors_BIN); 
....................          	//Get_Average_Center_Digital(sensors_BIN,2,12,&center);  
....................          	if(center==-1)	center=last_center; 
0E14:  MOV     848,W4
0E16:  MOV     #FFFF,W3
0E18:  CP      W3,W4
0E1A:  BRA     NZ,E20
0E1C:  PUSH    846
0E1E:  POP     848
.................... 			Print_Center(center); 
0E20:  PUSH    848
0E22:  POP     8A0
0E24:  CALL    B56
.................... 		 	last_center=center; 
0E28:  PUSH    848
0E2A:  POP     846
....................       	 	error=SET_POINT-center; 
0E2C:  MOV     #10,W4
0E2E:  MOV     848,W3
0E30:  SUB     W4,W3,W0
0E32:  MOV     W0,84C
.................... 		 	derivative=error-last_error; 
0E34:  MOV     84C,W4
0E36:  MOV     84A,W3
0E38:  SUB     W4,W3,W0
0E3A:  MOV     W0,84E
.................... 		 	integral=integral+(error/10); 
0E3C:  MOV     84C,W4
0E3E:  MOV     #A,W3
0E40:  REPEAT  #11
0E42:  DIV.S   W4,W3
0E44:  PUSH    42
0E46:  SETM.B  42
0E48:  CALL    596
0E4C:  POP     42
0E4E:  BCLR.B  43.0
0E50:  MOV     W0,W2
0E52:  MOV     W1,W3
0E54:  MOV     852,W0
0E56:  MOV     854,W1
0E58:  CALL    B88
0E5C:  MOV     W0,852
0E5E:  MOV     W1,854
.................... 	     	correction=error*(KP)+derivative*(KD)+integral*(KI); 
0E60:  MOV     84C,W5
0E62:  PUSH    42
0E64:  SETM.B  42
0E66:  MOV     W5,W0
0E68:  CALL    596
0E6C:  POP     42
0E6E:  PUSH    42
0E70:  SETM.B  42
0E72:  MOV     85A,W2
0E74:  MOV     85C,W3
0E76:  CALL    62E
0E7A:  POP     42
0E7C:  MOV     W0,W5
0E7E:  MOV     W1,W6
0E80:  MOV     84E,W7
0E82:  PUSH    42
0E84:  SETM.B  42
0E86:  MOV     W7,W0
0E88:  CALL    596
0E8C:  POP     42
0E8E:  PUSH    42
0E90:  SETM.B  42
0E92:  MOV     856,W2
0E94:  MOV     858,W3
0E96:  CALL    62E
0E9A:  POP     42
0E9C:  BCLR.B  43.0
0E9E:  MOV     W0,W2
0EA0:  MOV     W1,W3
0EA2:  MOV     W5,W0
0EA4:  MOV     W6,W1
0EA6:  CALL    B88
0EAA:  MOV     W0,W5
0EAC:  MOV     W1,W6
0EAE:  PUSH    42
0EB0:  SETM.B  42
0EB2:  MOV     852,W0
0EB4:  MOV     854,W1
0EB6:  MOV     85E,W2
0EB8:  MOV     860,W3
0EBA:  CALL    62E
0EBE:  POP     42
0EC0:  BCLR.B  43.0
0EC2:  MOV     W0,W2
0EC4:  MOV     W1,W3
0EC6:  MOV     W5,W0
0EC8:  MOV     W6,W1
0ECA:  CALL    B88
0ECE:  PUSH    42
0ED0:  SETM.B  42
0ED2:  CALL    56A
0ED6:  POP     42
0ED8:  MOV     W0,850
.................... 		 	last_error=error; 
0EDA:  PUSH    84C
0EDC:  POP     84A
....................          	left_correction=(base_speed)-correction; 
0EDE:  MOV     840,W4
0EE0:  MOV     850,W3
0EE2:  SUB     W4,W3,W0
0EE4:  MOV     W0,842
....................      	 	right_correction=(base_speed)+correction;       
0EE6:  MOV     840,W0
0EE8:  ADD     850,W0
0EEA:  MOV     W0,844
.................... 			Set_Motor_Duty(left_correction,right_correction); 
0EEC:  PUSH    42
0EEE:  SETM.B  42
0EF0:  PUSH    842
0EF2:  POP     8CE
0EF4:  PUSH    844
0EF6:  POP     8D0
0EF8:  CALL    1DC
0EFC:  POP     42
.................... 	  		delay_us(delay_time); 
0EFE:  MOV     866,W0
0F00:  CALL    D28
.................... 			//for(i=2;i<=12;i++)printf("%d",Sensors_BIN[i]); 
.................... 			//printf("%d\n\r",center); 
....................  
.................... 		} 
0F04:  BRA     DDA
.................... 	} 
0F06:  BRA     DA4
.................... } 
0F08:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C703   NOCKSFSM FRC_PLL16 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 8733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  
